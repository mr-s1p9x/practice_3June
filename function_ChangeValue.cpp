#include <iostream>
using namespace std;

void changeValue (int a, int b);
void changeValueWithPointers (int* a, int* b);

int main()
{
    int a = 10, b = 15;

    // Вывод начальных значений переменных a и b
    cout << "Before call functions: a = " << a << ", b = " << b << endl; // 10, 15

    // Вызов функции, которая пытается изменить значения a и b, но делает это локально
    changeValue(a, b); // Вызываем функцию замены

    // После вызова функции changeValue, значения a и b остаются неизменными в функции main
    // Ибо есть нюанс, при выходе из функции выше, мы теряем наши значения, а значит, получим все те же 10, 15
    cout << "After call 'changeValue': a = " << a << ", b = " << b << endl;

    // Вызов функции с передачей адресов переменных a и b
    changeValueWithPointers(&a, &b); // Функция замены по указателю

    // Здесь уже интереснее, т.к мы обращаемся непосредстенно к адресам переменных, меняя их значение,
    // то при выходе из функции мы значения не потеряем и получим на выходе уже 15, 10
    // Функция успешно изменяет значения a и b, так как работает с адресами (указателями) на исходные переменные
    cout << "After call 'changeValueWithPointers': a = " << a << ", b = " << b << endl;

    return 0;
}

// Функция, меняющая значения a и b, работает с копиями переданных переменных (передача по значению)
void changeValue(int a, int b)
{
    int tmp = a;  // Временная переменная для хранения значения a
    a = b;        // Присваивание a значения b
    b = tmp;      // Возвращение исходного значения a в b
}

// Функция, меняющая значения a и b, работает с указателями на исходные переменные (передача по указателю)
void changeValueWithPointers(int* a, int* b)
{
    int tmp = *a; // Разыменование указателя a для получения значения и сохранение его в tmp
    *a = *b;      // Разыменование указателя b и присваивание его значения разыменованному указателю a
    *b = tmp;     // Присваивание сохраненного значения tmp разыменованному указателю b
}
